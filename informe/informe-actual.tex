\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{geometry}
\geometry{margin=2.5cm}
\usepackage{graphicx}
\usepackage{amsmath, amssymb}
\usepackage{xcolor}
\usepackage{tikz, tcolorbox}
\usepackage{listings}
\usepackage{fancyvrb}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{float}
\usepackage{eso-pic}

\title {\includegraphics[width=0.4\textwidth]{ing-uni.jpg}\\[2ex]{\textbf{Informe Proyecto\\ Restaurante v1.1}\\[1.5ex] Programacion II\\[3ex]{\normalsize\textbf{Profesor:} Guido Mellado}\\[1ex]{\normalsize\textbf{Ayudantes:} Fernando Valdéz y Joaquín Cantero}}\\[12ex]}
\author{Diego Hernandez, Benjamin Soto, Eduardo Necul}
\date{20 Noviembre de 2025}

\lstset{
    backgroundcolor=\color{gray!10},
    basicstyle=\ttfamily\footnotesize,
    frame=single,
    breaklines=true,
    keywordstyle=\color{blue},
    commentstyle=\color{green!50!black},
    stringstyle=\color{orange},
    showstringspaces=false
}

\begin{document}

\AddToShipoutPictureFG{% Anadir a la pagina actual
  \AtPageUpperLeft{% Punto de referencia: esquina superior izquierda
    \put(0.5cm, -2.2cm){% Mover x cm a la derecha y x cm hacia abajo
      \includegraphics[width=8cm]{departamento-inf.png}
    }
  }
}
{% Agrego esto para poner el logo del departamento de informatica en la zona superior.
}

\maketitle

\newpage
\tableofcontents
\newpage

\section{Introduccion}

\textit{Se nos hizo entrega de un codigo base para la funcion de un restaurante incompleto, en el cual nosotros debemos encargarnos de completarlo y refinarlo con la forma de programar \textbf{POO} (Programacion Orientada a Objetos), sin salirnos de las casillas del esqueleto inicial. Ademas nos preocuparemos de explicar cada cambio aplicado al codigo, que utilidad le dimos a las funciones vacias y el diagrama de clases en base a este, v1.0.} Se plantea el objetivo de crear una base de datos y sincronizarla en nuestro proyecto mediante \textbf{ORM} (Object Relational Mapping), ademas de generar un \textbf{CRUD} (Create, Read, Update, Delete) para cada entidad siguiendo el concepto de un ORM con la herramienta SQLAlchemy, nos enfocamos en la creacion de una interfaz grafica con un manejo claro y facil de utilizar con la libreria Customtkinter con la intencion en que los usuarios puedan interactuar con el sistema sin dificultad alguna. Se utilizara programacion funcional como las expresiones lambda, map, filter y reduce. Se implementaran graficos sencillos que utilicen estadisticas basadas en los datos del sistema y se creara la simulacion de un proceso de compra para generar boletas y registrar pedidos, v1.1.

\newpage

\section{Diagrama de Clases}

Para visualizar con claridad el problema presentado y su diseño \textbf{POO}, diseñamos un diagrama UML con el objetivo de visualizar las distintas clases utilizadas y sus interrelaciones a través de relaciones (asociación, agrupación, composición) y cardinalidades.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.1\textwidth]{diagrama-restaurante.png}
    \caption{Diagrama de Clases de la aplicación.}.
\end{figure}

\newpage
\subsection{Explicacion del Diagrama}
La clase \textbf{\textit{AplicacionConPestanas}} es la principal clase del programa, ya que es ella la que se usa para configurar la interfaz de CustomTkinter e instanciar, relacionar y modificar el resto de clases del sistema, las cuales se describen a continuación brevemente:
\begin{itemize}

    \item La clase \textit{Stock} es aquella donde se administra la información de ingredientes, y que servirá para determinar la disponibilidad de menúes (o platos) en función de si existen los ingredientes requeridos o no, y tiene una relación de asociación con \textit{AplicacionConPestanas}, ya que pese a que esta última instancia un objeto Stock, no hay un contenedor de los objetos instanciados (lista) y ambas clases son independientes, en la que una referencia a otra.
    
    \item La clase \textit{Ingrediente} es aquella que configura la información de un ingrediente en base a sus tres atributos principales y que coinciden con el estándar de información del archivo CSV. Es el elemento principal de la clase Stock.
    
    \item La clase \textit{CrearMenu} es donde se configura la información de un menú/platillo y se configura en base a objetos Ingredientes, debido a la relación explicada en la clase Stock.
    \begin{itemize}
        \item[$\rightarrow$] Debido a la relación entre Stock y menúes, los objetos CrearMenu tienen una relación de agregación con los objetos Ingrediente, ya que toman ingredientes determinados y los configuran como parte de sus requisitos (los ingredientes requeridos o que forman parte de CrearMenu deben coincidir con ingredientes existentes en Stock).
        \item[$\rightarrow$] Exclusivamente, esta clase cuenta con una relación de abstracción + implementación con la clase IMenu, la cual corresponde a una interfaz que verifica que la construcción de CrearMenu cumpla los criterios solicitados.
    \end{itemize}
    
    \item La clase \textit{Pedido} es la clase donde se configura la información del pedido de un cliente en particular.
    
        \begin{itemize}
            \item[$\rightarrow$] La aplicación solo puede trabajar con máximo un Pedido a la vez, o con carencia de este, esto en una relación de asociación, ya que la existencia de ambos es bastante independiente (salvo por la instanciación que depende AplicacionConPestanas).
            \item[$\rightarrow$] La clase Pedido se configura en base a los menúes (CrearMenu) instanciados, y los va agregando en sí, teniendo la posibilidad de tener 1 o muchos menúes (de lo contrario Pedido estaría vacío y no habría datos con los que trabajar).
        \end{itemize}
        
    \item La clase \textit{BoletaFacade} tiene el proposito de generar la boleta de compra a partir de la recepcion de un objeto "pedido", pedido cual contiene lo comprado por el cliente en el restaurant.
    
    \item La clase \textit{CtkPDFViewer} es una clase auxiliar que sirve para crear la visualización del archivo PDF con la función de carga de PDF de \textit{AplicacionConPestanas}.
\end{itemize}

\newpage

\section{Diagrama Entidad-Relacion}

Para una mejor visualizacion del manejo de la base de datos, se creo un respectivo diagrama \textbf{MER} (Entidad-Relacion) con la funcion de ver sus respectivas cardinalidades, relaciones, entidades, atributos y propiedades, y mejorar la eficiencia en aplicar ORM, cambios, entre otros.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.1\textwidth]{diagrama-mer.png}
    \caption{Diagrama MER de la DB.}.
\end{figure}

\subsection{Explicacion del Diagrama}

En este diagrama se nos presentan 4 entidades, cuyo nombre son: cliente, pedido, menú e ingrediente, se presenta una relación cliente a pedido, donde UN cliente puede tener 0 o Muchos pedidos y donde los pedidos, 0 o Muchos, pueden estar compuestos de Uno o Muchos Menus, finalmente Menu posee una relación con la entidad Ingrediente de, 0 o Muchos Menu están asociado a Muchos ingredientes.\\

\textbf{Flujo:} Un cliente puede hacer un pedido o muchos pedidos, al hacer el pedido debera de seleccionar un menu para pedir o muchos si asi lo desea, al hacer un menú este requerirá de ingredientes, los cuales como mínimo deberán ser 2 o mas, es decir muchos ingrediente para preparar un respectivo menú.\\

\textbf{Nota:} Los rombos que se aprecian indican una tabla auxiliar, generada cuando existe una relación Muchos a Muchos y la cual hace de intermediario.

\section{Explicación abstracta del flujo del código}
Se abordara como indica el titulo, de manera abstracta el flujo del codigo, sin dar tantos detalles pero explicando lo suficiente para comprender en su totalidad el codigo hecho.

\subsection{Funcionamineto de la base de datos}

Para la persistencia de datos, abandonamos el uso de listas en memoria y archivos de texto simples. Implementamos una base de datos relacional \textbf{SQLite} gestionada completamente a través de un \textbf{ORM (Object-Relational Mapping)} con la librería \textbf{SQLAlchemy}. \\

Esto significa que no escribimos código SQL puro (como \lstinline{INSERT} o \lstinline{SELECT}), sino que manipulamos \textbf{Objetos Python} que el sistema traduce automáticamente a tablas y registros. \\

Los 4 pilares técnicos para el funcionamiento fueron: \\

\textbf{1. Validación de Conexión al Inicio} \\

Para cumplir con el requisito de seguridad, no solo configuramos el motor de base de datos, sino que implementamos una función ''ping'' que verifica que el archivo de base de datos esté accesible y no esté bloqueado \textbf{antes} de que la aplicación gráfica arranque. \\

\newpage

\textbf{Código clave (\lstinline{database.py} y \lstinline{app.py}):}

\begin{lstlisting}[language=Python, frame=single]
def verificar_conexion():
    try:
        # Intentamos ejecutar una consulta minima "SELECT 1"
        with engine.connect() as connection:
            connection.execute(text("SELECT 1"))
        return True
    except Exception:
        return False

# En app.py: Si esto retorna False, la app se cierra inmediatamente.
\end{lstlisting}
\vspace{3mm}

\textbf{2. Mapeo de Clases a Tablas (Modelos)} \\

Definimos la estructura de los datos en \lstinline{models.py}. Cada clase hereda de \lstinline{Base}, lo que le indica a SQLAlchemy que esa clase representa una tabla. \\

\textbf{Codigo clave (\lstinline{models.py}):}

\begin{lstlisting}[language=Python, frame=single]
class Cliente(Base):
    __tablename__ = 'cliente'
    # Definimos las columnas como atributos de la clase
    email = Column(String, primary_key=True) # PK evita duplicados fisicos
    nombre = Column(String, nullable=False)
\end{lstlisting}
\vspace{3mm}

\textbf{3. Integridad y Control de Duplicados} \\

Manejamos la prevención de duplicados en dos capas:

\begin{itemize}
    \item[1.] \textbf{Capa de Base de Datos:} Usando \lstinline{primary\_key=True} (por ejemplo, en el Email del cliente), el motor SQLite rechaza físicamente inserciones repetidas. 
    \item[2.] \textbf{Capa Lógica (CRUD):} Antes de intentar guardar, consultamos si el registro existe para dar una respuesta amigable al usuario en lugar de un error crítico.
\end{itemize}

\textbf{Código clave (\lstinline{cliente_crud.py}):}

\begin{lstlisting}[language=Python, frame=single]
# Verificacion previa
if db.query(Cliente).filter_by(email=email).first():
    print("El cliente ya existe")
    return None
\end{lstlisting}
\vspace{3mm}

\newpage

\textbf{4. Transacciones Atómicas y Rollback Automático} \\

Este es el punto más crítico para la integridad de los datos. Usamos el patrón \textbf{Unit of Work}. Todas las operaciones de escritura están envueltas en un bloque \lstinline{try-except}.

\begin{itemize}
    \item Si todo sale bien $\rightarrow$ \lstinline{db.commit()} (Se guardan los cambios).
    \item Si ocurre \textbf{cualquier error} $\rightarrow$ \lstinline{db.rollback()} (Se deshacen los cambios pendientes).
\end{itemize}

Esto asegura que nunca se guarden datos a medias (por ejemplo, un pedido sin cliente). \\

\textbf{Código clave (Patrón usado en todos los CRUDs):}

\begin{lstlisting}[language=Python, frame=single]
try:
    db.add(nuevo_registro)
    db.commit()      # Confirma la transaccion
    db.refresh(nuevo_registro)
except SQLAlchemyError:
    db.rollback()    # Deshace cambios si hay error
    print("Error en la transaccion, se aplico rollback.")
\end{lstlisting}

\newpage

\subsection{Pestaña de ingredientes/stock}

El funcionamiento de la pestaña \textbf{Stock/ingredientes}, se debe a la implementación de una arquitectura modular que separa la \textbf{interfaz gráfica} (frontend) de la \textbf{lógica de datos} (backend), utilizando el modulo \textbf{SQLAlchemy} como ORM y aplicando principios de \textbf{programación orientada a funciones}. \\

Hay 4 pilares técnicos que dan vida al modulo, que son: \\

\textbf{1. Integración con Base de Datos vía ORM} \\

En lugar de usar consultas SQL crudas (como \texttt{INSERT INTO...}), utilizamos \textbf{SQLAlchemy}.

\begin{itemize}
    \item Definimos la clase \lstinline{Ingrediente} en \lstinline{models.py}, que mapea directamente a una tabla en la base de datos.
    \item Esto nos permite manipular los ingredientes como \textbf{objetos de Python}. Para guardar un ingrediente, simplemente instanciamos la clase y usamos \lstinline{db.add()} y \lstinline{db.commit()}, lo que garantiza la integridad de los datos y facilita el mantenimiento.
\end{itemize}

\textbf{2. Lógica de Negocio con Programación Funcional (CRUD)} \\

Toda la lógica pesada se delegó al archivo \lstinline{ingrediente\_crud.py}. Aquí es donde cumplimos con el requisito avanzado de la rúbrica:

\begin{itemize}
    \item \textbf{Validacion con} \lstinline{lambda}: En lugar de múltiples \lstinline{if}, definimos funciones anónimas (\lstinline{lambda}) para validar que el nombre no esté vacío y que el stock sea positivo en una sola línea.
    \item \textbf{Filtrado con} \lstinline{filter}: Para la funcionalidad de \textbf{"Ver Bajo Stock"}, no usamos un bucle \lstinline{for} tradicional. Usamos la función \lstinline{filter()} junto con una \lstinline{lambda} para extraer eficientemente solo los ingredientes con cantidad menor a 5.
\end{itemize}

\textbf{3. Carga Masiva Robusta (CSV)} \\

Implementamos un importador de archivos CSV ''inteligente'' capaz de manejar errores comunes:

\begin{itemize}
    \item \textbf{Codificacion} \lstinline{utf-8-sig}: Para leer correctamente archivos generados en Excel que incluyen caracteres ocultos (BOM).
    \item \textbf{Limpieza de Datos:} Usamos \lstinline{map} y compresión de listas para normalizar los nombres de las columnas (quitar espacios, minúsculas).
    \item \textbf{Lógica ''Upsert''}: El sistema detecta si el ingrediente ya existe. Si existe, \textbf{suma} el stock al actual; si no, lo \textbf{crea}. Esto evita duplicados y permite reabastecer inventario fácilmente.
\end{itemize}

\textbf{4. Interfaz Reactiva (\lstinline{app.py})} \\

La interfaz gráfica (construida con \lstinline{customtkinter}) actúa solo como un ''puente''.

\begin{itemize}
    \item No contiene lógica de negocio.
    \item Su única función es capturar los datos del usuario, llamar a los métodos estáticos del \lstinline{IngredienteCRUD} y refrescar la tabla (\lstinline{Treeview}) con la respuesta de la base de datos.
\end{itemize}

\subsection{Pestaña de menus}

Para que funcione la pestaña de menús, tuvimos que resolver un desafío técnico principal: \textbf{Un menú no es solo un nombre, es una receta}. Esto implica que un Menú tiene muchos Ingredientes, y cada Ingrediente tiene una \textbf{cantidad específica} para ese Menú. \\

Para lograrlo, implementamos una arquitectura basada en 3 conceptos clave: \\

\textbf{1. Modelo de Datos: Clase de Asociación (Association Object)} \\

En lugar de una relación simple "Muchos a Muchos", implementamos una \textbf{Clase de Asociación} llamada \lstinline{MenuIngrediente}.

\begin{itemize}
    \item \textbf{¿Por que?} Porque una tabla intermedia normal solo guarda IDs. Nosotros necesitábamos guardar la \lstinline{cantidad\_requerida} de cada ingrediente (ej: para un "Completo", necesitamos 1 Pan y 0.5 Tomate).
\end{itemize}

\textbf{Código Clave (\lstinline{models.py}):}

\begin{lstlisting}[language=Python, frame=single]
class MenuIngrediente(Base):
    # Relaciona Menú e Ingrediente y agrega el dato "cantidad"
    menu_id = Column(Integer, ForeignKey('menu.id'), primary_key=True)
    ingrediente_id = Column(Integer, ForeignKey('ingrediente.id'), primary_key=True)
    cantidad_requerida = Column(Float, nullable=False) # <--- El dato clave
\end{lstlisting}
\vspace{3mm}

\textbf{2. Lógica con Programación Funcional} \\

En el archivo \lstinline{menu\_crud.py}, utilizamos programación funcional para procesar la receta antes de guardarla. Esto cumple con el requisito avanzado de la rúbrica.

\begin{itemize}
    \item \textbf{Validación (\lstinline{filter}):} Limpiamos los datos de entrada eliminando cualquier ingrediente con cantidad negativa o cero.
    \item \textbf{Verificación de Stock (\lstinline{reduce}):} En lugar de usar bucles \lstinline{for} complejos, usamos \lstinline{reduce} para verificar si \textbf{todos} los ingredientes de la receta tienen stock suficiente en una sola operación lógica.
    \item \textbf{Transformación (\lstinline{map}):} Convertimos la lista de datos crudos (tuplas) en objetos de base de datos (\lstinline{MenuIngrediente}).
\end{itemize}

\textbf{Código Clave (\lstinline{menu\_crud.py}):}

\begin{lstlisting}[language=Python, frame=single]
# 1. Filtrar invalidos
items_validos = list(filter(lambda item: item[1] > 0, lista_ingredientes))

# 2. Validar stock masivo (Reduce colapsa todo a True o False)
es_posible = reduce(lambda acc, item: acc and verificar_stock(item), items_unicos, True)

# 3. Mapear a objetos (Map)
receta_objetos = list(map(lambda item: MenuIngrediente(...), items_unicos))
\end{lstlisting}
\vspace{3mm}

\textbf{3. Solución al "Detached Instance Error" (Carga Ansiosa)} \\

Uno de los problemas más difíciles fue mostrar la receta en la tabla. SQLAlchemy por defecto es ''perezoso'' (Lazy Loading) y cierra la conexión antes de cargar los ingredientes, lo que causaba errores. 

\begin{itemize}
    \item \textbf{Solución:} Implementamos \lstinline{joinedload} \textbf{(Eager Loading)}. Esto le ordena a la base de datos traer el Menú y sus Ingredientes en una sola consulta SQL, asegurando que los datos estén disponibles incluso después de cerrar la sesión.
\end{itemize}

\begin{lstlisting}[language=Python, frame=single]
# Traemos el Menu + La relacion intermedia + El nombre del ingrediente
return db.query(Menu).options(
    joinedload(Menu.ingredientes_receta).joinedload(MenuIngrediente.ingrediente)
).all()
\end{lstlisting}


\end{document}
